<?xml version="1.0" encoding="UTF-8"?>
<chapter id="index"><?dbhtml dir="solidity" ?>
	<title>智能合约语言 Solidity v0.5.0</title>
	<subtitle>本文作者最近在找工作，有意向致电 13113668890</subtitle>
	<info>
		<keywordset>
			<keyword>ethereum</keyword>
			<keyword>geth</keyword>
			<keyword>browser-solidity</keyword>
			<keyword>solidity</keyword>
		</keywordset>
	</info>
	<para>Solidity 是什么？Solidity是以太坊智能合约的编程语言。</para>

	<section id="browser-solidity">
		<title>Remix</title>
		<para>
			在线使用 Remix
			<ulink url="https://remix.ethereum.org/">https://remix.ethereum.org/</ulink>
		</para>
		<para>国内网络有时不给力，建议将 Remix 安装到本地目录。</para>
		<section>
			<title>NodeJS</title>
			<screen>
			<![CDATA[
cd /usr/local/src
wget https://nodejs.org/dist/v18.4.0/node-v18.4.0-linux-x64.tar.xz
tar xf node-v18.4.0-linux-x64.tar.xz
mv node-v18.4.0-linux-x64 /srv/node-v18.4.0
rm -f /srv/node
ln -s /srv/node-v18.4.0 /srv/node

alternatives --install /usr/local/bin/node node /srv/node/bin/node 100 \
--slave /usr/local/bin/npm npm /srv/node/bin/npm \
--slave /usr/local/bin/npx npx /srv/node/bin/npx \
--slave /usr/local/bin/corepack corepack /srv/node/bin/corepack

node -v
			]]>
			</screen>
		</section>
		<section>
			<title>Remix Project</title>
			<para>Docker 安装 Remix</para>
			<screen>
			<![CDATA[
cd /usr/local/src
wget https://nodejs.org/dist/v18.4.0/node-v18.4.0-linux-x64.tar.xz
tar xf node-v18.4.0-linux-x64.tar.xz
mv node-v18.4.0-linux-x64 /srv/node-v18.4.0
rm -f /srv/node
ln -s /srv/node-v18.4.0 /srv/node

alternatives --install /usr/local/bin/node node /srv/node/bin/node 100 \
--slave /usr/local/bin/npm npm /srv/node/bin/npm \
--slave /usr/local/bin/npx npx /srv/node/bin/npx \
--slave /usr/local/bin/corepack corepack /srv/node/bin/corepack

node -v
			]]>
			</screen>
			<screen>
			<![CDATA[
npm install -g @remix-project/remixd			
			]]>
			</screen>
			<para></para>
			<screen>
			<![CDATA[
[root@netkiller ~]# curl -sL https://dl.yarnpkg.com/rpm/yarn.repo -o /etc/yum.repos.d/yarn.repo
[root@netkiller ~]# dnf install -y yarn
[root@netkiller ~]# yarn global bin
[root@netkiller ~]# yarn global add @remix-project/remixd
[root@netkiller ~]# remixd -v
0.6.2
			]]>
			</screen>
			<para></para>
			<screen>
			<![CDATA[
[root@netkiller ~]# su - docker
Last login: Fri Jul  1 13:27:58 CST 2022 on pts/0
[docker@netkiller ~]$ ls
remix
[docker@netkiller ~]$ cd remix/
[docker@netkiller remix]$ ls
docker-compose.yaml
[docker@netkiller remix]$ cat docker-compose.yaml 
version: "3.9"

networks:
  ethereum:

services:
  remixide:
    restart: always
    image: remixproject/remix-ide:latest
    container_name: remixide
    ports: 
      - 8080:80
      - 65520:65520
    networks:
      - ethereum			
			]]>
			</screen>
		</section>

		<section>
			<title>Remix 桌面版</title>
			<para>
				<ulink src="https://github.com/ethereum/remix-desktop/releases" />
			</para>
		</section>
		<section>
			<title>输入数组</title>
			<programlisting>
			<![CDATA[
	function mint(address[] _to, uint256 _value) public returns (bool success) {
        for (uint i=0; i<_to.length; i++) {
            balanceOf[_to[i]] = _value;
        }
        return true;
    }
			]]>
			</programlisting>
			<para>在Remix中输入数组的方法</para>
			<screen>
			<![CDATA[
["0x6F56648fbD2306f843442f8dC61d5C8861Fac7C9","0x81b7E08F65Bdf5648606c89998A9CC8164397647"]			
			]]>
			</screen>
		</section>
	</section>
	<section id="solc">
		<title>solc 命令</title>

		<section>
			<title>使用 solc 编译 *.sol 代码</title>
			<screen>
			<![CDATA[
neo@netkiller ~/ethereum/solidity % solc --bin --abi --optimize -o ./output helloworld.sol
neo@netkiller ~/ethereum/solidity % find output         
output
output/HelloWorld.bin
output/HelloWorld.abi			
			]]>
			</screen>
		</section>
	</section>
	<section id="solidity.Getting.Started">
		<title>智能合约入门演示</title>
		<para>这里我们先做一个 Helloword 演示，让你初步对智能合约有一个大概的认识。</para>
		<tip>
			<para>需要注意的是，你在网上会看到很多例子，对照这例子一步一步操作，始终无法成功，这根Solidity的版本有很大关系。
			</para>
		</tip>
		<para>将下面代码粘贴到 </para>
		<programlisting>
			<![CDATA[
pragma solidity ^0.4.25;

contract HelloWorld
{
    string tmp;

    function HelloWorld() public
    {

    }

    function get() public constant returns (string)
    {
        return tmp;
    }

    function set(string _tmp) public
    {
        tmp = _tmp;
    }

}
			]]>
		</programlisting>
		<para>Compile - Details - WEB3DEPLOY</para>
		<programlisting>
			<![CDATA[
var helloworldContract = web3.eth.contract([{"constant":false,"inputs":[{"name":"_tmp","type":"string"}],"name":"set","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"get","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"}]);
var helloworld = helloworldContract.new(
   {
     from: web3.eth.accounts[0], 
     data: '0x6060604052341561000f57600080fd5b6102e38061001e6000396000f30060606040526004361061004c576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680634ed3885e146100515780636d4ce63c146100ae575b600080fd5b341561005c57600080fd5b6100ac600480803590602001908201803590602001908080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050509190505061013c565b005b34156100b957600080fd5b6100c1610156565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156101015780820151818401526020810190506100e6565b50505050905090810190601f16801561012e5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b80600090805190602001906101529291906101fe565b5050565b61015e61027e565b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156101f45780601f106101c9576101008083540402835291602001916101f4565b820191906000526020600020905b8154815290600101906020018083116101d757829003601f168201915b5050505050905090565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061023f57805160ff191683800117855561026d565b8280016001018555821561026d579182015b8281111561026c578251825591602001919060010190610251565b5b50905061027a9190610292565b5090565b602060405190810160405280600081525090565b6102b491905b808211156102b0576000816000905550600101610298565b5090565b905600a165627a7a72305820ea826c30d131f20a4d3a8e3fb059ffa95f4c222a5b099029750e4c1937b46e5b0029', 
     gas: '4700000'
   }, function (e, contract){
    console.log(e, contract);
    if (typeof contract.address !== 'undefined') {
         console.log('Contract mined! address: ' + contract.address + ' transactionHash: ' + contract.transactionHash);
    }
 })
			]]>
		</programlisting>

		<para>部署智能合约需要消耗 gas 所以你要先解锁账号。</para>
		<screen>
			<![CDATA[
> personal.unlockAccount("0x83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6", "", 300)
true			
			]]>
		</screen>

		<screen>
			<![CDATA[
> var helloworldContract = web3.eth.contract([{"constant":false,"inputs":[{"name":"_tmp","type":"string"}],"name":"set","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"get","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"}]);
undefined
> var helloworld = helloworldContract.new(
...    {
......      from: web3.eth.accounts[0], 
......      data: '0x6060604052341561000f57600080fd5b6102e38061001e6000396000f30060606040526004361061004c576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680634ed3885e146100515780636d4ce63c146100ae575b600080fd5b341561005c57600080fd5b6100ac600480803590602001908201803590602001908080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050509190505061013c565b005b34156100b957600080fd5b6100c1610156565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156101015780820151818401526020810190506100e6565b50505050905090810190601f16801561012e5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b80600090805190602001906101529291906101fe565b5050565b61015e61027e565b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156101f45780601f106101c9576101008083540402835291602001916101f4565b820191906000526020600020905b8154815290600101906020018083116101d757829003601f168201915b5050505050905090565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061023f57805160ff191683800117855561026d565b8280016001018555821561026d579182015b8281111561026c578251825591602001919060010190610251565b5b50905061027a9190610292565b5090565b602060405190810160405280600081525090565b6102b491905b808211156102b0576000816000905550600101610298565b5090565b905600a165627a7a72305820ea826c30d131f20a4d3a8e3fb059ffa95f4c222a5b099029750e4c1937b46e5b0029', 
......      gas: '4700000'
......    }, function (e, contract){
......     console.log(e, contract);
......     if (typeof contract.address !== 'undefined') {
.........          console.log('Contract mined! address: ' + contract.address + ' transactionHash: ' + contract.transactionHash);
.........     }
......  })
null [object Object]
undefined
			]]>
		</screen>
		<para>helloworld 智能合约已经创建完毕</para>
		<screen>
			<![CDATA[
> helloworld
{
  abi: [{
      constant: false,
      inputs: [{...}],
      name: "set",
      outputs: [],
      payable: false,
      stateMutability: "nonpayable",
      type: "function"
  }, {
      constant: true,
      inputs: [],
      name: "get",
      outputs: [{...}],
      payable: false,
      stateMutability: "view",
      type: "function"
  }, {
      inputs: [],
      payable: false,
      stateMutability: "nonpayable",
      type: "constructor"
  }],
  address: undefined,
  transactionHash: "0x466c9ad9db8f37ed5b65bc261210da92f51364ebab1dcbd3759bfc3e16ad6502"
}
			
			]]>
		</screen>
	</section>
	<section>
		<title>Helloworld Example</title>
		<programlisting>
		<![CDATA[
// SPDX-License-Identifier: MIT
// http://www.netkiller.cn/blockchain/
pragma solidity ^0.8.15;

contract HelloWorld
{
    string private tmp;

    constructor() {

    }

    function set(string memory _tmp) public 
    {
        tmp = _tmp;
    }

    function get() public view returns (string memory)
    {
        return tmp;
    }

}
		]]>
		</programlisting>
	</section>
	<section id="solidity.type">
		<title>数据类型</title>
		<section id="solidity.type.integer">
			<title>数值型</title>
			<para>int/uint：变长的有符号或无符号整型。变量支持的步长以8递增，支持从uint8到uint256，以及int8到int256。需要注意的是，uint和int默认代表的是uint256和int256。
			</para>
			<para>有符号整型能够表示负数的代价是其能够存储正数的范围的缩小，因为其约一半的数值范围要用来表示负数。如：uint8的存储范围为0
				~ 255，而int8的范围为-127 ~ 127
			</para>
			<para>支持的运算符:</para>
			<literallayout>
			<![CDATA[
比较：<=，<，==，!=，>=，>，返回值为bool类型。

位运算符：&，|，（^异或），（~非）。

数学运算：+，-，一元运算+，*，/，（%求余），（**次方），（<<左移），（>>右移）。
			]]>
			</literallayout>
			<para>小数由"."组成，在他的左边或右边至少要包含一个数字。如"1."，".1"，"1.3"均是有效的小数。</para>
			<section>
				<title>加 +，减 -，乘 *，除 ／ 运算演示</title>
				<programlisting>
				<![CDATA[
pragma solidity ^0.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract Math {

  function mul(int a, int b) public pure returns (int) {

      int c = a * b;
      return c;
  }

  function div(int a, int b) public pure  returns (int) {

      int c = a / b;
      return c;
  }

  function sub(int a, int b) public pure  returns (int) {
      
      return a - b;
  }

  function add(int a, int b) public pure  returns (int) {

      int c = a + b;
      return c;
  }
}				
				]]>
				</programlisting>
			</section>
			<section>
				<title>求余 % 运算演示</title>
				<programlisting>
				<![CDATA[
pragma solidity ^0.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract Math {

  function m(int a, int b) public pure returns (int) {

      int c = a % b;
      return c;
  }
}				
				]]>
				</programlisting>
			</section>
			<section>
				<title>幂运算演示</title>
				<programlisting>
				<![CDATA[
pragma solidity ^0.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract Math {

  function m(uint a, uint b) public pure returns (uint) {

      uint c = a**b;
      return c;
  }

}				
				]]>
				</programlisting>
			</section>
			<section>
				<title>与 &amp;，| 或，非 ～，异或 ^ 演示</title>
				<programlisting>
				<![CDATA[
pragma solidity ^0.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract Math {

  function yu() public pure returns (uint) {

      uint a = 3; // 0b0011
      uint b = 4; // 0b0100
    
      uint c = a & b; // 0b0000
      return c; // 0
  }

  function huo() public pure returns (uint) {

      uint a = 3; // 0b0011
      uint b = 4; // 0b0100
    
      uint c = a | b; // 0b0111
      return c; // 7
  }

  function fei() public pure returns (uint8) {

      uint8 a = 3; // 0b00000011
      uint8 c = ~a; // 0b11111100
      return c; // 0
  }
  
  function yihuo() public pure returns (uint) {

      uint a = 3; // 0b0011
      uint b = 4; // 0b0100
    
      uint c = a ^ b; // 0b0111
      return c; // 252
  }
}
				]]>
				</programlisting>
			</section>
			<section>
				<title>位移演示</title>
				<programlisting>
				<![CDATA[
pragma solidity ^0.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn

contract Math {

  function leftShift() public pure returns (uint8) {

      uint8 a = 8; // 0b00001000
      uint8 c = a << 2; // 0b00100000
      return c; // 32
  }

  function rightShift() public pure returns (uint8) {

      uint8 a = 8; // 0b00001000
      uint8 c = a >> 2; // 0b00000010
      return c; // 2
  }

}
				]]>
				</programlisting>
				<literallayout>
				<![CDATA[
a << n 表示a的二进制位向左移动n位，在保证位数没有溢出的情况下等价于 a乘以2的n次方。
a >> n 表示a的二进制位向右移动n位，在保证位数没有溢出的情况下等价于 a除以2的n次方。				
				]]>
				</literallayout>
			</section>
		</section>
		<section id="solidity.type.string">
			<title>字符串</title>
			<para>string 字符串类型，字符串可以通过""或者''来定义字符串的值</para>
			<programlisting>
			<![CDATA[
pragma solidity ^0.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract StringTest {

    string name;
    
    function StringTest() public{
        name = "default";
    }
    function setName(string _name) public{
        name = _name;
    }
    function getName() public view returns(string){
        return name;
    }
}			
			]]>
			</programlisting>
			<section>
				<title>获取字符串长度</title>
				<para>在 Solidity 中想获得字符串长度必须转成 bytes 类型然后使用 length
					属性获得。bytes(string).length
				</para>
				<programlisting>
				<![CDATA[
pragma solidity ^0.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract StringTest {
    
    
    string public name = "http://www.netkiller.cn";
    

    function nameBytes() public constant returns (bytes) {
        
        return bytes(name);
    }
    
    function nameLength() public constant returns (uint) {
        
        return bytes(name).length;
    }

    function length(string _name) public pure returns (uint) {
        
        return bytes(_name).length;
    }
    
}
				]]>
				</programlisting>
				<tip>
					<para>注意：汉字采用UTF8编码，一个汉字等于3个字节，当你使用 length("景峯") 测试时会返回长度 6。</para>
				</tip>
			</section>
		</section>
		<section id="solidity.type.bool">
			<title>布尔(Booleans)</title>
			<para>bool: 可能的取值为常量值true和false。支持的运算符：</para>
			<screen>
			<![CDATA[
! 逻辑非

&& 逻辑与

|| 逻辑或

== 等于

!= 不等于

bool a = true;
bool b = !a;

// a == b -> false
// a != b -> true
// a || b -> true
// a && b -> false			
			]]>
			</screen>
		</section>
		<section id="solidity.type.bytes">
			<title>字节类型</title>
			<screen>
			<![CDATA[

bytes names = "netkiller"
bytes9 _names = "netkiller";
bytes(name)[0] = 0xFF;

bytes memory _tmp = new bytes(3);
_tmp[0] = 0x4e;
_tmp[1] = 0x65;
_tmp[2] = 0x6f;
			]]>
			</screen>
			<programlisting>
			<![CDATA[
pragma solidity ^0.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract BytesTest {
    
    bytes names = "netkiller";
    
    function get() public view returns (bytes) {
        
        return names;
    }
    function getBytes2() public pure returns (bytes2) {
        bytes9 _names = "netkiller";
        return bytes2(_names);
    }
    function bytesToString() public constant returns (string) {
        
        return string(names);
    }
   
    function copyBytes(bytes b) public pure returns (bytes) {
       
       bytes memory tmp = new bytes(b.length);
       
       for(uint i = 0; i < b.length; i++) {
           
           tmp[i] = b[i];
       }
       
       return tmp;
    }
    
    function bytesToString2() public pure returns (string) {
        bytes memory _tmp = new bytes(3);
        _tmp[0] = 0x4e;
        _tmp[1] = 0x65;
        _tmp[2] = 0x6f;
        return string(_tmp);
    }
   
}			
			]]>
			</programlisting>
			<para>.length可以动态修改字节数组的长度</para>
			<programlisting>
			<![CDATA[
pragma solidity ^0.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract BytesTest2 {
    
    // 初始化一个两个字节空间的字节数组
    bytes public array = new bytes(2);
    
    // 设置修改字节数组的长度
    function setLength(uint _len) public {
        array.length = _len;
    }
    
    // 返回字节数组的长度
    function getLength() constant public returns (uint) {
        return array.length;
    }
    
    // 往字节数组中添加字节
    function pushArray(byte _tmp) public{
        array.push(_tmp);
    }
    
}			
			]]>
			</programlisting>
		</section>
		<section id="solidity.type.array">
			<title>数组</title>
			<programlisting>
				<![CDATA[
	//创建一个memory的数组
	uint[] memory a = new uint[](7);
	
	uint[] x = [uint(1), 3, 4];
	
    bytes memory b = new bytes(10);
				]]>
			</programlisting>
			<para>二维数组</para>
			<programlisting>
			<![CDATA[
uint [2][3] T = [[1,2],[3,4],[5,6]];			
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
pragma solidity ^0.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract ArrayTest {
    
    uint [] array = [1,2,3,4,5];
    
    // 通过for循环计算数组内部的值的总和
    function sum() constant public returns (uint) {
        uint num = 0;
        for(uint i = 0; i < array.length; i++) {
            num = num + array[i];
        }
        return num;
    }
    
    function sumNumbers(uint[] _numbers) public pure returns (uint) {
        uint num = 0;
        for(uint i = 0; i < _numbers.length; i++) {
            num = num + _numbers[i];
        }
        return num;
    }
    
}
			]]>
			</programlisting>
			<section>
				<title>length</title>
				<para>.length 属性是活动数组的尺寸</para>
				<programlisting>
				<![CDATA[
pragma solidity ^0.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract ArrayLength {
    
    uint [] array = [1,2,3,4,5];
    
    function getLength() public constant returns (uint) {
        
        return array.length;
    }
    
}				
				]]>
				</programlisting>
			</section>
			<section>
				<title>push() 方法</title>
				<para>通过 push 可以向数组中添加数据</para>
				<programlisting>
				<![CDATA[
pragma solidity ^0.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract ArrayLength {
    
    uint [] array = [1,2,3,4,5];
    
    function pushArray() public {
        
        array.push(6);
    }
    
    function getLength() public constant returns (uint) {
        
        return array.length;
    }
    
}				
				]]>
				</programlisting>
			</section>
		</section>
		<section id="solidity.enum">
			<title>枚举类型</title>
			<para>State
				就是一个自定义的整型，当枚举数不够多时，它默认的类型为uint8，当枚举数足够多时，它会自动变成uint16，枚举下标定义从左至右从零开始。
			</para>
			<para>New=0, Pending=1, Done=2, Deleted=3</para>
			<para>访问枚举方式 State.New 实际等于数字 0</para>
			<programlisting>
			<![CDATA[
pragma solidity ^0.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract EnumTest {
    enum State { New, Pending, Done, Deleted }
    State state = State.New;

    function set(State _state) public {
        state = _state;
    }

    function get() constant public returns (State) {
        return state;
    }

}			
			]]>
			</programlisting>
			<para>枚举用来定义状态</para>
			<programlisting>
				<![CDATA[
pragma solidity ^0.4.0;

contract Purchase {
    enum State { Created, Locked, Inactive } // Enum
}				
				]]>
			</programlisting>

		</section>
		<section id="solidity.struct">
			<title>结构体</title>
			<para>定义结构体</para>
			<screen>
				<![CDATA[
	struct Voter {
        uint weight; // weight is accumulated by delegation
        bool voted;  // if true, that person already voted
        address delegate; // person delegated to
        uint vote;   // index of the voted proposal
    }

    // This is a type for a single proposal.
    struct Proposal {
        bytes32 name;   // short name (up to 32 bytes)
        uint voteCount; // number of accumulated votes
    }			
				]]>
			</screen>
			<para>演示例子</para>
			<programlisting>
				<![CDATA[
pragma solidity ^0.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract Students {
    
    struct Person {
        string name;
        uint age;
        uint class;
        
    }

    Person person = Person("Neo",18,1);

    function getPerson() public view returns(string){
        return person.name;
    }
}				
				]]>
			</programlisting>
			<section>
				<title>函数返回Struct</title>
				<para>Struct 不知直接返回，解决方法如下</para>
				<programlisting>
				<![CDATA[
pragma solidity ^0.4.19;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract Netkiller {
    struct JobStruct {
      uint a;
      uint b;
      uint c;
    }

    function getValues () public pure returns (uint, uint, uint) {
      JobStruct memory js = JobStruct(1, 2, 3);
      return (js.a, js.b, js.c);
    }
}				
				]]>
				</programlisting>
			</section>
		</section>
		<section id="solidity.type.address">
			<title>address</title>
			<screen>
				<![CDATA[
address public minter;
				]]>
			</screen>
			<para>下面是一个获得账号余额的例子。</para>
			<programlisting>
			<![CDATA[
pragma solidity ^0.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract AddressTest{
    
    function getBalance(address _addr) public constant returns (uint){
        return _addr.balance;
    }

}			
			]]>
			</programlisting>
			<section>
				<title>payable</title>

			</section>
			<section>
				<title>.value()</title>

			</section>
			<section>
				<title>.gas()</title>

			</section>
		</section>
		<section id="solidity.type.mapping">
			<title>mapping</title>
			<para>mapping 就是图数据结构，由 key 和 value 组成。</para>
			<programlisting>
			<![CDATA[
pragma solidity ^0.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract MappingExample {
    
    mapping(uint => string) map;

    function put(uint key, string value) public {
        map[key] = value;
    }
    
    function get(uint key) constant public returns (string) {
        return map[key];
    }
}			
			]]>
			</programlisting>
		</section>
	</section>
	<section id="solidity.unit">
		<title>单位</title>
		<section id="ether.units">
			<title>货币单位（Ether Units）</title>
			<literallayout>
			<![CDATA[
kwei (1000 Wei)
mwei (1000 KWei)
gwei (1000 mwei)
szabo (1000 gwei)
finney (1000 szabo)
ether (1000 finney)

以太币单位其实是密码学家的名字，是以太坊创始人为了纪念他们在数字货币的领域的贡献。他们分别是：
wei: Wei Dai 戴伟 密码学家 ，发表 B-money
finney: Hal Finney 芬尼 密码学家、工作量证明机制（POW）提出
szabo: Nick Szabo 尼克萨博 密码学家、智能合约的提出者
			]]>
			</literallayout>
			<programlisting>
			<![CDATA[
pragma solidity ^0.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract UnitTest {
    function tf() public pure returns (bool) {
      if (1 ether == 1000 finney){
          return true;
      }
      return false;
    }
    
    function ts() public pure returns (bool) {
      if (1 ether == 1000000 szabo){
          return true;
      }
      return false;
    }
    
    function tgw() public pure returns (bool) {
      if (1 ether == 1000000000000000000 wei){
          return true;
      }
      return false;
    }
}			
			]]>
			</programlisting>
		</section>
		<section>
			<title>时间单位（Time Units）</title>
			<para>时间单位: seconds, minutes, hours, days, weeks,
				years均可做为后缀，并进行相互转换，规则如下：
			</para>
			<literallayout>
			<![CDATA[
1 == 1 seconds (默认是seconds为单位)
1 minutes == 60 seconds
1 hours == 60 minutes
1 days == 24 hours
1 weeks = 7 days
1 years = 365 days

由于无法预测闰秒，必须由外部的预言（oracle）来更新从而得到一个精确的日历库。
所以使用这些单位进行日期计算需要特别小心，因为不是每年都是365天，且并不是每天都有24小时，因为还有闰秒。		
			]]>
			</literallayout>
		</section>
	</section>
	<section id="solidity.variable">
		<title>变量</title>
		<programlisting>
			<![CDATA[
address public minter;
string name;
int num;	

    uint constant x = 32**22 + 8;
    string constant text = "abc";
    bytes32 constant myHash = keccak256("abc");
    
    uint256 ticket = 1 ether;
			]]>
		</programlisting>
		<para>变量赋值</para>
		<programlisting>
			<![CDATA[
pragma solidity ^0.4.25;

contract C {
    uint[] data;

    function f() public view returns (uint, bool, uint) {
        return (7, true, 2);
    }

    function g() public {
        // 声明和分配变量。 明确指定类型是不可能的。
        var (x, b, y) = f();
        // 分配给一个预先存在的变量。
        (x, y) = (2, 7);
        // 互换值的常用技巧对于非价值存储类型不起作用。
        (x, y) = (y, x);
        // 组件可以省略（也可以用于变量声明）。
        // 如果元组以空组件结束，其余的值将被丢弃。
        (data.length,) = f(); // 设置长度为 7
        // 在左边也可以做同样的事情。
        (,data[3]) = f(); // Sets data[3] to 2
        // 组件只能在作业的左侧排除，但有一个例外：
        (x,) = (1,);
        // (1,) 是指定1元组元的唯一方法，因为（1）等于1。
    }
}			
			]]>
		</programlisting>
		<section>
			<title>全局变量</title>

			<programlisting>
			<![CDATA[
block.blockhash(uint blockNumber) returns (bytes32): hash of the given block - only
works for 256 most recent blocks
block.coinbase (address): current block miner’s address
block.difficulty (uint): current block difficulty
block.gaslimit (uint): current block gaslimit
block.number (uint): current block number
block.timestamp (uint): current block timestamp
msg.data (bytes): complete calldata
msg.gas (uint): remaining gas
msg.sender (address): sender of the message (current call)
msg.value (uint): number of wei sent with the message
now (uint): current block timestamp (alias for block.timestamp)
tx.gasprice (uint): gas price of the transaction
6.4. Solidity in Depth 99Solidity Documentation, 0.4.10
tx.origin (address): sender of the transaction (full call chain)
revert(): abort execution and revert state changes
keccak256(...) returns (bytes32): compute the Ethereum-SHA-3 (Keccak-256) hash of the
(tightly packed) arguments
sha3(...) returns (bytes32): an alias to keccak256()
sha256(...) returns (bytes32): compute the SHA-256 hash of the (tightly packed) arguments
ripemd160(...) returns (bytes20): compute the RIPEMD-160 hash of the (tightly packed) arguments
ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address):
recover address associated with the public key from elliptic curve signature, return zero on error
addmod(uint x, uint y, uint k) returns (uint): compute (x + y) % k where the addition is performed with arbitrary precision and does not wrap around at 2**256
mulmod(uint x, uint y, uint k) returns (uint): compute (x * y) % k where the multiplication is performed with arbitrary precision and does not wrap around at 2**256
this (current contract’s type): the current contract, explicitly convertible to address
super: the contract one level higher in the inheritance hierarchy
selfdestruct(address recipient): destroy the current contract, sending its funds to the given address
.balance (uint256): balance of the Address in Wei
.send(uint256 amount) returns (bool): send given amount of Wei to Address, returns false on failure
.transfer(uint256 amount): send given amount of Wei to Address, throws on failure			
			]]>
			</programlisting>
			<literallayout>
			<![CDATA[
block.blockhash(uint blockNumber) returns (bytes32): 某个区块的区块链hash值
block.coinbase (address): 当前区块的挖矿地址
block.difficulty (uint): 当前区块的难度
block.gaslimit (uint): 当前区块的gaslimit
block.number (uint): 当前区块编号
block.timestamp (uint): 当前区块时间戳
msg.data (bytes): 参数数据
msg.gas (uint): 剩余的gas
msg.sender (address): 当前发送消息的地址，执行合约的地址。
msg.sig (bytes4): 方法ID
msg.value (uint): 执行合约时，转账的eth数量，以wei为单位。
now (uint): 时间戳，等价于block.timestamp (uint)
tx.gasprice (uint): 交易的gas单价
tx.origin (address):交易发送地址		
			]]>
			</literallayout>
		</section>
		<section id="variable.storage">
			<title>storage</title>
			<para>使用 storage 这个关键字时，当前的函数必须是internal或者private类型。</para>
		</section>
		<section id="variable.memory">
			<title>memory</title>
		</section>
	</section>
	<section id="solidity.function">
		<title>函数</title>
		<section>
			<title>构造方法</title>
			<para>构造方法的定义是 contract 与 function 相同</para>
			<programlisting>
				<![CDATA[
pragma solidity ^0.4.18;

contract MyContractByNetkiller {
    /* Constructor */

    function MyContractByNetkiller() public{

    }
}
				]]>
			</programlisting>
		</section>
		<section>
			<title>定义函数</title>
			<para>没有返回值</para>
			<programlisting>
				<![CDATA[
	function setName(string _name) public{
        name = _name;
    }			
				]]>
			</programlisting>
		</section>
		<section>
			<title>函数返回值</title>
			<para>有返回值</para>
			<programlisting>
				<![CDATA[
	function getName() public view returns(string){
        return name;
    }
				]]>
			</programlisting>
		</section>
		<section id="solidity.func.param">
			<title>参数传递</title>
			<para>除了 f(2,3) 这样传递参数，还可以使用类似字典或Map的方式 f({value: 2, key: 3});
			</para>
			<programlisting>
				<![CDATA[
pragma solidity ^0.4.0;

contract C {
    function f(uint key, uint value) {
        // ...
    }

    function g() {
        // named arguments
        f({value: 2, key: 3});
    }
}				
				]]>
			</programlisting>
		</section>
		<section>
			<title>函数的例子</title>
			<para>完整的例子</para>
			<programlisting>
				<![CDATA[
pragma solidity ^0.4.18;

contract MyContractByNetkiller {
    /* Constructor */
    string name;
    int num;
    function MyContractByNetkiller() public{
        name = "default";
        num = 1;
    }
    function setName(string _name) public{
        name = _name;
    }
    function getName() public view returns(string){
        return name;
    }
    function setNum(int n) public{
        num = n;
    }
    function addNum(int m) public view returns(int res){
        res = m + num;
    }
}
				]]>
			</programlisting>
		</section>
		<section id="function.Fallback">
			<title>Fallback function</title>
			<programlisting>
				<![CDATA[
				
				]]>
			</programlisting>
		</section>
		<section id="solidity.modifier">
			<title>modifier</title>
			<para>modifier 可以理解为 function 的触发器，或者理解为 hook。执行 function的时候会首先运行
				modifier
			</para>
			<para>_; 表示执行 modifier 完成所有命令后，继续运行 function 内的逻辑。</para>
			<screen>
				<![CDATA[
pragma solidity ^0.4.11;  
  
contract owned {  
    function owned() { owner = msg.sender; }  
    address owner;    
    uint price;
    mapping (address => bool) registeredAddresses;
  
    modifier onlyOwner {  
        require(msg.sender == owner);  
        _;  
    } 
    function changePrice(uint _price) onlyOwner {  
        price = _price;  
    } 
    function close() onlyOwner {  
        selfdestruct(owner);  
    }  
}
				]]>
			</screen>
		</section>
	</section>
	<section id="solidity.event">
		<title>事件</title>
		<para>什么是 event 呢？ 在 Solidity 中 event 类似触发器，是合约与外部程序连接接口。</para>
		<para>外部程序监听事件，智能合约中的事件一旦触发，就将数据交给监听程序处理。</para>
		<para>换个角度，如果你懂得消息队列，那么只能合约中的 event 是消息发布者，外部的event 监听程序是消息的消费者。</para>
		<para>使用 event 来创建,下面是 ERC20 的标准 event.</para>
		<programlisting>
			<![CDATA[
event Transfer(address indexed from, address indexed to, uint256 value);
			]]>
		</programlisting>
		<para>事件名称你可以随意定义，开头字母大写即可，参数传递根据你的实际需要增加。</para>
		<programlisting>
		<![CDATA[
event Sent(address from, address to, uint amount);		
		]]>
		</programlisting>
	</section>


	<section id="solidity.oop">
		<title>面向对象编程</title>
		<section>
			<title>可见性修饰符</title>
			<para>Solidity对函数和状态变量提供了四种可见性。分别是external,public,internal,private。其中函数默认是public。状态变量默认的可见性是internal。</para>
			<screen>
			<![CDATA[
internal - 状态变量默认为internal类型，函数只能通过内部访问（当前合约或者继承的合约），可在当前合约或继承合约中调用。类似于Java的protected
public - public标识的函数是合约接口的一部分。可以通过内部，或者消息来进行调用。与Java的public含义一致。
external - external标识的函数是合约接口的一部分。函数只能通过外部的方式调用。外部函数在接收大的数组时更有效。Java中无与此对应的关键字。
private - 只能在当前合约内访问，在继承合约中都不可访问。与Java中的private含义一致。

payable ：可支付的函数修饰符，没有该修饰符无法接受转账操作。
			]]>
			</screen>
		</section>
		<section>
			<title>错误处理</title>
			<literallayout>
			<![CDATA[


assert(bool condition)：不满足条件，将抛出异常

require(bool condition)：不满足条件，将抛出异常

revert() 抛出异常			
			]]>
			</literallayout>
			<programlisting>
			<![CDATA[
if(msg.sender != owner) { revert(); }
assert(msg.sender == owner);
require(msg.sender == owner);			
			]]>
			</programlisting>
		</section>
		<section id="solidity.interface">
			<title>interface 接口</title>
			<para>接口是抽象的合约，接口中不能实现方法。</para>
			<itemizedlist>
				<title>接口：</title>
				<listitem>
					<para>不能继承其他合约或接口</para>
				</listitem>
				<listitem>
					<para>不能定义构造方法</para>
				</listitem>
				<listitem>
					<para>不能定义变量</para>
				</listitem>
				<listitem>
					<para>不能定义结构体</para>
				</listitem>
				<listitem>
					<para>不能定义枚举</para>
				</listitem>
			</itemizedlist>
			<para></para>
			<programlisting>
		<![CDATA[
pragma solidity ^0.4.11;

interface Token {
    function transfer(address recipient, uint amount) public;
}
		]]>
			</programlisting>
		</section>
		<section id="solidity.library">
			<title>library 库</title>
			<para>定义 library</para>
			<programlisting>
		<![CDATA[
pragma solidity ^0.4.25;

// This is the same code as before, just without comments
library Set {
  struct Data { mapping(uint => bool) flags; }

  function insert(Data storage self, uint value)
      public
      returns (bool)
  {
      if (self.flags[value])
        return false; // already there
      self.flags[value] = true;
      return true;
  }

  function remove(Data storage self, uint value)
      public
      returns (bool)
  {
      if (!self.flags[value])
          return false; // not there
      self.flags[value] = false;
      return true;
  }

  function contains(Data storage self, uint value)
      public
      view
      returns (bool)
  {
      return self.flags[value];
  }
}


		]]>
			</programlisting>
			<para>调用库中的函数</para>
			<programlisting>
		<![CDATA[
contract C {
    using Set for Set.Data; // this is the crucial change
    Set.Data knownValues;

    function register(uint value) public {
        // Here, all variables of type Set.Data have
        // corresponding member functions.
        // The following function call is identical to
        // `Set.insert(knownValues, value)`
        require(knownValues.insert(value));
    }
}
		]]>
			</programlisting>
			<section>
				<title>使用库来扩展数据类型</title>
				<programlisting>
			<![CDATA[
pragma solidity ^0.4.25;

library Search {
    function indexOf(uint[] storage self, uint value)
        public
        view
        returns (uint)
    {
        for (uint i = 0; i < self.length; i++)
            if (self[i] == value) return i;
        return uint(-1);
    }
}

contract C {
    using Search for uint[];
    uint[] data;

    function append(uint value) public {
        data.push(value);
    }

    function replace(uint _old, uint _new) public {
        // This performs the library function call
        uint index = data.indexOf(_old);
        if (index == uint(-1))
            data.push(_new);
        else
            data[index] = _new;
    }
}			
			]]>
				</programlisting>
			</section>
		</section>
		<section id="solidity.is">
			<title>继承</title>
			<para>例子 mortal 继承 owned</para>
			<programlisting>
				<![CDATA[
pragma solidity ^0.4.11;  
  
contract owned {  
    function owned() { owner = msg.sender; }  
    address owner;  
  
    modifier onlyOwner {  
        require(msg.sender == owner);  
        _;  
    }  
}  
  
  
contract mortal is owned {  
    function close() onlyOwner {  
        selfdestruct(owner);  
    }  
}
				]]>
			</programlisting>
		</section>
	</section>
	<section id="solidity.call">
		<title>合约调用</title>
		<programlisting>
		<![CDATA[
address token = 0xdC7c2ab64Bc6861852C0Cd60B79564164eD890CF;
token.call(bytes4(sha3("fun(uint256)")), a);		
		]]>
		</programlisting>
		<programlisting>
		<![CDATA[
Function: transfer(address _to, uint256 _value)
MethodID: 0xa9059cbb		

token.call('0xa9059cbb', _to, _value);


pragma solidity ^0.4.24;

contract Test{
    address public token;
    
    constructor(address _contractAddress) public {
        token = _contractAddress; 
    }
    function transfer(address _to, uint256 _value) public returns (bool success){
        if(token.call(bytes4(keccak256("fun(address, uint256)")), _to, _value)){
            return false;
        }
        return true;
    }
}
		]]>
		</programlisting>
	</section>
	<section id="solidity.payable">
		<title>合约接收 ETH</title>
		<para>首先你需要在智能合约中定义这个函数 function () payable public {}，这时这个合约地址就可以接收ETH了。</para>

		<para>测试方法，向合约地址发送ETH即可。</para>
		<section id="">
			<title>调用 selfdestruct(msg.sender); 取出合约中的 ETH</title>
			<programlisting>
			<![CDATA[
			
			
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
pragma solidity ^0.4.24;

contract NetkillerCashier {

    function () payable public {}

    function claim() public {
        selfdestruct(msg.sender);
    }
}
			]]>
			</programlisting>
			<para>https://ropsten.etherscan.io/tx/0x6504df0e18416c3c319f1f11f84ffa40a752b47c257faee58a7ef2c8ef78cc45</para>
			<screen>
			<![CDATA[
 Contract 0x0896827f5e3d2683763321bdf780bde1824f6137  
 TRANSFER  0.03 Ether from 0x0896827f5e3d2683763321bdf780bde1824f6137 to  0x22c57f0537414fd95b9f0f08f1e51d8b96f14029
 SELF-DESTRUCT Contract 0x0896827f5e3d2683763321bdf780bde1824f6137			
			]]>
			</screen>
			<para>查看 Code https://ropsten.etherscan.io/address/0x0896827f5e3d2683763321bdf780bde1824f6137#code 显示</para>
			<screen>
			<![CDATA[
Contract SelfDestruct called at TxHash 0x6504df0e18416c3c319f1f11f84ffa40a752b47c257faee58a7ef2c8ef78cc45			
			]]>
			</screen>
		</section>
		<section>
			<title>自动退款合约</title>
			<para>本合约只收取 1 ETH 多余 ETH 将退给用户</para>
			<programlisting>
			<![CDATA[
pragma solidity ^0.4.24;

// Author: netkiller@msn.com
// Website: http://www.netkiller.cn

contract Refund {
    
    address owner = 0x0;
  
    uint256 ticket = 1 ether;
    
    constructor() public payable {
        owner = msg.sender;
    }

    function () public payable {
        require(msg.value >= ticket);
        if (msg.value > ticket) {
            uint refundFee = msg.value - ticket;
            msg.sender.transfer(refundFee);
        }
    }
}
			]]>
			</programlisting>
		</section>
		<section id="">
			<title>收款合约自动转账</title>
			<para>合约收到ETH后自动转到 owner 账号中。</para>
			<programlisting>
			<![CDATA[
pragma solidity ^0.4.24;

contract NetkillerCashier {
    
    address public owner;

    constructor() public payable {
        owner = msg.sender;
    }
    function () payable public {
        owner.transfer(msg.value);
    }

}			
			]]>
			</programlisting>
		</section>
		<section id="">
			<title>指定账号提取 ETH</title>
			<programlisting>
			<![CDATA[
pragma solidity ^0.4.24;

contract NetkillerCashier {

    address public owner;
    uint public amount;
    
    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
    
    constructor() public {
        owner = msg.sender;
    }

    function () public payable {
        amount += msg.value;
    }

	function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function withdraw() onlyOwner public {
        msg.sender.transfer(amount);
        amount = 0;
    }

}			
			]]>
			</programlisting>
			<screen>
			<![CDATA[
function transferOwnership(address newOwner) 可以修改指定账号提取 ETH
function withdraw()	提取 ETH 的函数
			]]>
			</screen>
			<para>https://ropsten.etherscan.io/tx/0xadad8c4cd7649d825fb8c362e97f80c4821b07c97d423050289986bd75703b78</para>
			<screen>
			<![CDATA[
 Contract 0xb31fb5297340a06e1af3e21c1780b7001db6890a  
 TRANSFER  0.05 Ether from 0xb31fb5297340a06e1af3e21c1780b7001db6890a to  0x22c57f0537414fd95b9f0f08f1e51d8b96f14029			
			]]>
			</screen>
		</section>
	</section>
	<section id="solidity.contract.interface">
		<title>合约中实例化一个接口</title>
		<para>在合约中调用一个已经存在的合约。</para>
		<programlisting>
		<![CDATA[
pragma solidity ^0.4.24;

/******************************************/
/*      Netkiller Crowdsale Contract      */
/******************************************/
/* Author netkiller <netkiller@msn.com>   */
/* Home http://www.netkiller.cn           */
/* Version 2018-06-07 - Solc ver: 0.4.24  */
/******************************************/

interface token {
	function balanceOf(address _address) constant external returns (uint256);
    function transfer(address receiver, uint amount) external;
}

contract Netkiller {
    
    token public tokenContract;

    constructor(address addressOfToken) public {
        tokenContract = token(addressOfToken);
    }
	function getBalance(address _address) view public returns (uint256){
        return tokenContract.balanceOf(_address);
    }
    function transfer(address _to, uint256 _value) payable public{
        tokenContract.transfer(_to, _value);
    }

    
}
		]]>
		</programlisting>

	</section>
	<section id="solidity.contract.new">
		<title>合约中实例化另一个合约</title>
		<para>当合约已经部署到链上，如需扩展合约的功能可以采用此种方法。</para>
		<programlisting>
		<![CDATA[
pragma solidity ^0.4.24;

contract ERC20 {
    uint256 public totalSupply;
    uint public decimals;
    function balanceOf(address _address) constant public returns (uint256);
    function transfer(address _to, uint256 _value) public returns (bool success);
}
contract NetkillerBatchTransfer {

    ERC20 public token;
    
    constructor(address _contractAddress) public {
        token = ERC20(_contractAddress);
    }
    function getBalance(address _address) view public returns (uint256){
        return token.balanceOf(_address);
    }
}		
		]]>
		</programlisting>
		<section id="">
			<title>msg.sender 与 this 的区别</title>
			<para>当一个合约访问另一个合约是，msg.sender 与 this 的区别是什么呢？</para>
			<programlisting>
			<![CDATA[
pragma solidity ^0.4.24;

/******************************************/
/*       Netkiller Mini TOKEN             */
/******************************************/
/* Author netkiller <netkiller@msn.com>   */
/* Home http://www.netkiller.cn           */
/* Version 2018-05-31 Fixed transfer bool */
/******************************************/

contract NetkillerMiniToken {

    constructor() public { }

    function test1() public view returns (address addr){
        return msg.sender;
    }
    function test2() public view returns (address addr){
        return this;
    }
}			
			]]>
			</programlisting>
			<para>例子</para>
			<screen>
			<![CDATA[
Contract A: 0xf328c11c4df88d18fcbd30ad38d8b4714f4b33bf
Contract B: 0xb9b7e0cb2edf5ea031c8b297a5a1fa20379b6a0a
			]]>
			</screen>
			<para>Contract A 调用 Contract B</para>
			<screen>
			<![CDATA[
msg.sender 	= 0xF328c11c4dF88d18FcBd30ad38d8B4714F4b33bF
this		= 0xB9B7e0cb2EDF5Ea031C8B297A5A1Fa20379b6A0a			
			]]>
			</screen>
			<para></para>
		</section>
		<section id="">
			<title>地址格式</title>
			<para>在合约中出现地址，例如下面：</para>
			<programlisting>
			<![CDATA[
pragma solidity ^0.4.24;
contract ERC20 {
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}

contract TestContract{
    ERC20 public token = ERC20(0xAeeD5A0C200efA0670330d0C7509C854c52AF859);

    function tot() public view returns (uint){
        return token.totalSupply();
    }

    function balance(address _address) public view returns (uint){
        return token.balanceOf(_address);
    }

}			
			]]>
			</programlisting>
			<para>合约中不支持全小写的地址。</para>
			<screen>
			<![CDATA[
正确的：0xAeeD5A0C200efA0670330d0C7509C854c52AF859
错误的：0xaeed5a0c200efa0670330d0c7509c854c52af859			
			]]>
			</screen>
		</section>
	</section>
	<section id="solidity.sectury">
		<title>Solidity 安全问题</title>
		<section>
			<title>整型溢出</title>
			<para>什么是整型溢出呢？在solidity编写合约时，定义整型一般是用uint8, uint256。一个变量如果定义为uint8表示的无符号的8位整型，即取值范围为0-255。当给这个变量赋值256时，即整型溢出变成了0，以此类推257变成了1。</para>
			<programlisting>
			<![CDATA[
pragma solidity ^0.4.24;

//author: netkiller <netkiller@msn.com>
//homepage: http://www.netkiller.cn

contract NetkillerOverflowTest{
    

    function add(uint8 a, uint8 b) pure public returns (uint8){
        
        uint8 result = a + b;
        
        return result;
        
    }
    
    function sub(uint8 a, uint8 b) pure public returns (uint8){
        
        uint8 result = a - b;
        
        return result;
        
    }
    
    function mul(uint8 a, uint8 b) pure public returns (uint8){
        
        uint8 result = a * b;
        
        return result;
        
    }
    
    function div(uint8 a, uint8 b) pure public returns (uint8){
        
        uint8 result = a / b;
        
        return result;
        
    }
    
}		
			]]>
			</programlisting>
			<para>调用上面合约，运行结果</para>
			<screen>
			<![CDATA[
254 + 1 = 255
254 + 2 = 0
254 + 3 = 1
			]]>
			</screen>
			<para>减法运行结果</para>
			<screen>
			<![CDATA[
10 - 20 = 246
			]]>
			</screen>
			<para>乘法运行结果</para>
			<screen>
			<![CDATA[
51 * 5 = 255
51 * 6 = 50
			]]>
			</screen>
			<para>再来测试乘法</para>
			<screen>
			<![CDATA[
255 / 10 = 25			
			]]>
			</screen>
			<para>这有点想千年虫问题，即99年变成00年后，你无法区分1900年还是2000年。</para>
			<para>现在测试一下uint256，uint256支持的取值范围是0到2^256-1</para>
			<programlisting>
			<![CDATA[
pragma solidity ^0.4.24;

//author: netkiller <netkiller@msn.com>
//homepage: http://www.netkiller.cn

contract TestUint256Overflow {
    // (2**256 – 1) + 1 = 0 向上溢出测试
    function overflow() pure public returns (uint256 _overflow) {
        uint256 max = 2 ** 256 - 1;
        return max + 1;
    }

    // 0 – 1 = 2**256 – 1 向下溢出测试
    function underflow() pure public returns (uint256 _underflow) {
        uint256 min = 0;
        return min - 1;
    }
}
			]]>
			</programlisting>
			<para>运行结果</para>
			<screen>
			<![CDATA[
_overflow : 0
_underflow : 115792089237316195423570985008687907853269984665640564039457584007913129639935
			]]>
			</screen>
			<para>第一个函数溢出为 0，第二个函数 0 - 1 = 115792089237316195423570985008687907853269984665640564039457584007913129639935</para>
			<para>解决溢出问题使用SafeMath库</para>
			<programlisting>
			<![CDATA[
pragma solidity ^0.4.24;

//author: netkiller <netkiller@msn.com>
//homepage: http://www.netkiller.cn

library SafeMath {

  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    if (a == 0) {
      return 0;
    }

    c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    return a / b;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
}

contract NetkillerSafeMath {
 
    using SafeMath for uint256;    
    
    function add(uint256 a, uint256 b) pure public returns (uint256){
        uint256 result = a.add(b);
        return result;
    }
    function sub(uint256 a, uint256 b) pure public returns (uint256){
        uint256 result = a.sub(b);
        return result;
    }
    function mul(uint256 a, uint256 b) pure public returns (uint256){
        uint256 result = a.mul(b);
        return result;
    }
    function div(uint256 a, uint256 b) pure public returns (uint256){
        uint256 result = a.div(b);
        return result;
    }
}			
			]]>
			</programlisting>
			<para>测试 SafeMath</para>
			<programlisting>
			<![CDATA[
add(115792089237316195423570985008687907853269984665640564039457584007913129639934,1)  => 115792089237316195423570985008687907853269984665640564039457584007913129639935
add(115792089237316195423570985008687907853269984665640564039457584007913129639935,1)  => 抛出异常


			]]>
			</programlisting>
		</section>
	</section>
	<section id="solidity.example">
		<title>solidity example</title>
		<section id="voting">
			<title>Voting</title>
			<programlisting>
			<![CDATA[
pragma solidity ^0.4.25;
//author: netkiller <netkiller@msn.com>
//homepage: http://www.netkiller.cn
contract Voting {

  mapping (bytes32 => uint8) public votesReceived;

  // 存储候选人名字的数组
  bytes32[] public candidateList;


  // 构造函数 初始化候选人名单
  function Voting(bytes32[] candidateNames) public {

    candidateList = candidateNames;
  }

  // 查询某个候选人的总票数
  function totalVotesFor(bytes32 candidate) public constant returns (uint8) {
    require(validCandidate(candidate) == true);
    // 或者
    // assert(validCandidate(candidate) == true);
    return votesReceived[candidate];
  }

  // 为某个候选人投票
  function voteForCandidate(bytes32 candidate) public{
    assert(validCandidate(candidate) == true);
    votesReceived[candidate] += 1;
  }

  // 检索投票的姓名是不是候选人的名字
  function validCandidate(bytes32 candidate) public constant returns (bool) {
    for(uint i = 0; i < candidateList.length; i++) {
      if (candidateList[i] == candidate) {
        return true;
      }
    }
    return false;
  }

}
			]]>
			</programlisting>
		</section>

		<section id="MetaCoin">
			<title>MetaCoin</title>
			<programlisting>
			<![CDATA[
pragma solidity ^0.4.25;
contract MetaCoin {
	mapping (address => uint) balances;
	event Transfer(address indexed _from, address indexed _to, uint256 _value);
	function MetaCoin() public {
		balances[tx.origin] = 10000;
	}
	function sendCoin(address receiver, uint amount) public returns(bool sufficient) {
		if (balances[msg.sender] < amount) return false;
		balances[msg.sender] -= amount;
		balances[receiver] += amount;
		Transfer(msg.sender, receiver, amount);
		return true;
	}
	function getBalance(address addr) public view returns(uint) {
		return balances[addr];
	}
}
			]]>
			</programlisting>
		</section>

		<section>
			<title>Anonymous voting on Ethereum without a tally authority. Protocol from this paper</title>
			<para>
				<ulink url="https://github.com/stonecoldpat/anonymousvoting">https://github.com/stonecoldpat/anonymousvoting</ulink>
			</para>
		</section>

		<section id="Ballot">
			<title>Ballot</title>
			<programlisting>
			<![CDATA[
pragma solidity ^0.4.0;
contract Ballot {

    struct Voter {
        uint weight;
        bool voted;
        uint8 vote;
        address delegate;
    }
    struct Proposal {
        uint voteCount;
    }

    address chairperson;
    mapping(address => Voter) voters;
    Proposal[] proposals;

    /// Create a new ballot with $(_numProposals) different proposals.
    function Ballot(uint8 _numProposals) public {
        chairperson = msg.sender;
        voters[chairperson].weight = 1;
        proposals.length = _numProposals;
    }

    /// Give $(toVoter) the right to vote on this ballot.
    /// May only be called by $(chairperson).
    function giveRightToVote(address toVoter) public {
        if (msg.sender != chairperson || voters[toVoter].voted) return;
        voters[toVoter].weight = 1;
    }

    /// Delegate your vote to the voter $(to).
    function delegate(address to) public {
        Voter storage sender = voters[msg.sender]; // assigns reference
        if (sender.voted) return;
        while (voters[to].delegate != address(0) && voters[to].delegate != msg.sender)
            to = voters[to].delegate;
        if (to == msg.sender) return;
        sender.voted = true;
        sender.delegate = to;
        Voter storage delegateTo = voters[to];
        if (delegateTo.voted)
            proposals[delegateTo.vote].voteCount += sender.weight;
        else
            delegateTo.weight += sender.weight;
    }

    /// Give a single vote to proposal $(toProposal).
    function vote(uint8 toProposal) public {
        Voter storage sender = voters[msg.sender];
        if (sender.voted || toProposal >= proposals.length) return;
        sender.voted = true;
        sender.vote = toProposal;
        proposals[toProposal].voteCount += sender.weight;
    }

    function winningProposal() public constant returns (uint8 _winningProposal) {
        uint256 winningVoteCount = 0;
        for (uint8 prop = 0; prop < proposals.length; prop++)
            if (proposals[prop].voteCount > winningVoteCount) {
                winningVoteCount = proposals[prop].voteCount;
                _winningProposal = prop;
            }
    }
}			
			]]>
			</programlisting>

		</section>

		<section>
			<title>Conference</title>
			<programlisting>
			<![CDATA[
pragma solidity ^0.4.25;

contract Conference {
  address public organizer;
  mapping (address => uint) public registrantsPaid;
  uint public numRegistrants;
  uint public quota;

  event Deposit(address _from, uint _amount);  // so you can log these events
  event Refund(address _to, uint _amount); 

  function Conference() public{ // Constructor
    organizer = msg.sender;
    quota = 500;
    numRegistrants = 0;
  }
  function buyTicket() public payable returns (bool success) {
    if (numRegistrants >= quota) { return false; }
    registrantsPaid[msg.sender] = msg.value;
    numRegistrants++;
    Deposit(msg.sender, msg.value);
    return true;
  }
  function changeQuota(uint newquota) public {
    if (msg.sender != organizer) { return; }
    quota = newquota;
  }
  function refundTicket(address recipient, uint amount) public {
    if (msg.sender != organizer) { return; }
    if (registrantsPaid[recipient] == amount) { 
      address myAddress = this;
      if (myAddress.balance >= amount) { 
        recipient.transfer(amount);
        registrantsPaid[recipient] = 0;
        numRegistrants--;
        Refund(recipient, amount);
      }
    }
  }
  function destroy() public{ // so funds not locked in contract forever
    if (msg.sender == organizer) { 
      selfdestruct(organizer); // send funds to organizer
    }
  }
}
			]]>
			</programlisting>
			<para>控制台调试</para>
			<screen>
			<![CDATA[
var contract;
Conference.deployed().then(function(instance){contract=instance;});
contract.buyTicket();
			]]>
			</screen>
			<para>测试程序</para>
			<programlisting>
			<![CDATA[
neo@MacBook-Pro ~/ethereum/Conference % cat test/conference.js 
var Conference = artifacts.require("./Conference.sol");

contract('Conference', function(accounts) {
	console.log(accounts);
	var owner_account = accounts[0];
    var sender_account = accounts[1];

  it("Initial conference settings should match", function(done) {
  	
  	Conference.deployed({from: owner_account}).then(function(conference) {
        conference.quota.call().then(function(quota) { 
                assert.equal(quota, 100, "Quota doesn't match!"); 
        }).then(function() { 
                return conference.numRegistrants.call(); 
        }).then(function(num) { 
                assert.equal(num, 0, "Registrants doesn't match!");
                return conference.organizer.call();
        }).then(function(organizer) { 
                assert.equal(organizer, owner_account, "Owner doesn't match!");
                done();
        }).catch(done);
  	}).catch(done);
  });

  it("Should update quota", function(done) {
  	
  	Conference.deployed({from: owner_account}).then(function(conference) {
        conference.quota.call().then(
            function(quota) { 
                assert.equal(quota, 100, "Quota doesn't match!"); 
        }).then(
            function() { 
                return conference.changeQuota(300);
        }).then(
            function() { 
                return conference.quota.call()
        }).then(
            function(quota) { 
                assert.equal(quota, 300, "New quota is not correct!");
                done();
        }).catch(done);
  	}).catch(done);
  });


  it("Should let you buy a ticket", function(done) {

  	Conference.deployed({ from: accounts[0] }).then(function(conference) {

        var ticketPrice = web3.toWei(.05, 'ether');
        var initialBalance = web3.eth.getBalance(conference.address).toNumber();  

  			conference.buyTicket({ from: accounts[1], value: ticketPrice }).then(
          function() {
  					var newBalance = web3.eth.getBalance(conference.address).toNumber();
            var difference = newBalance - initialBalance;
  					assert.equal(difference, ticketPrice, "Difference should be what was sent");
  					return conference.numRegistrants.call(); 
  			}).then(
  				function(num) { 
  					assert.equal(num, 1, "there should be 1 registrant");
  					return conference.registrantsPaid.call(sender_account);
  			}).then(
  				function(amount) {
  					assert.equal(amount.toNumber(), ticketPrice, "Sender's paid but is not listed as paying");	
  					return web3.eth.getBalance(conference.address);
  			}).then(
  				function(bal) {
            assert.equal(bal.toNumber(), ticketPrice, "Final balance mismatch");
  					done();
  			}).catch(done);
  	}).catch(done);
  });

  it("Should issue a refund by owner only", function(done) {
    
    Conference.deployed({ from: accounts[0] }).then(function(conference) {

        var ticketPrice = web3.toWei(.05, 'ether');
        var initialBalance = web3.eth.getBalance(conference.address).toNumber(); 

        conference.buyTicket({ from: accounts[1], value: ticketPrice }).then(
          function() {
            var newBalance = web3.eth.getBalance(conference.address).toNumber();
            var difference = newBalance - initialBalance;
            assert.equal(difference, ticketPrice, "Difference should be what was sent");

            // Now try to issue refund as second user - should fail
            return conference.refundTicket(accounts[1], ticketPrice, {from: accounts[1]});
        }).then(
          function() {  
            var balance = web3.eth.getBalance(conference.address);
            assert.equal(balance, ticketPrice, "Balance should be unchanged");
            // Now try to issue refund as organizer/owner
            return conference.refundTicket(accounts[1], ticketPrice, {from: accounts[0]});
        }).then(
          function() {
            var postRefundBalance = web3.eth.getBalance(conference.address).toNumber();
            assert.equal(postRefundBalance, initialBalance, "Balance should be initial balance");
            done();
        }).catch(done);
      }).catch(done);
    });

});			
			]]>
			</programlisting>
		</section>
	</section>
	<section id="zeppelin.solidity">
		<title>Zeppelin Solidity - OpenZeppelin is a library for writing secure Smart Contracts on Ethereum.</title>
		<para>OpenZeppelin is an open framework of reusable and secure smart contracts in the Solidity language.</para>
		<para>
			网站：
			<ulink url="https://openzeppelin.org">https://openzeppelin.org</ulink>
		</para>
		<para>
			Github:
			<ulink url="https://github.com/OpenZeppelin/zeppelin-solidity">https://github.com/OpenZeppelin/zeppelin-solidity</ulink>
		</para>
		<section>
			<title>安装</title>
			<screen>
			<![CDATA[
npm install @openzeppelin/contracts			
			]]>
			</screen>
		</section>
		<section id="zeppelin.ERC20">
			<title>ERC20</title>
			<programlisting>
			<![CDATA[
// contracts/GLDToken.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract GLDToken is ERC20 {
    constructor(uint256 initialSupply) ERC20("Gold", "GLD") {
        _mint(msg.sender, initialSupply);
    }
}
			]]>
			</programlisting>
		</section>
		<section id="zeppelin.ERC872">
			<title>ERC872</title>
			<para>创建项目目录</para>
			<screen>
			<![CDATA[
neo@MacBook-Pro ~/ethereum/truffle % mkdir TokenERC827
neo@MacBook-Pro ~/ethereum/truffle % cd TokenERC827 
neo@MacBook-Pro ~/ethereum/truffle/TokenERC827 % truffle init
Downloading...
Unpacking...
Setting up...
Unbox successful. Sweet!

Commands:

  Compile:        truffle compile
  Migrate:        truffle migrate
  Test contracts: truffle test
			]]>
			</screen>

			<para>安装 zeppelin-solidity</para>
			<screen>
			<![CDATA[
neo@MacBook-Pro ~/ethereum/truffle/TokenERC827 % npm init -y
Wrote to /Users/neo/ethereum/truffle/TokenERC827/package.json:

{
  "name": "TokenERC827",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}

neo@MacBook-Pro ~/ethereum/truffle/TokenERC827 % npm install -E zeppelin-solidity
npm notice created a lockfile as package-lock.json. You should commit this file.
npm WARN TokenERC827@1.0.0 No description
npm WARN TokenERC827@1.0.0 No repository field.

+ zeppelin-solidity@1.7.0
added 8 packages in 2.591s


   ╭─────────────────────────────────────╮
   │                                     │
   │   Update available 5.6.0 → 5.7.1    │
   │       Run npm i npm to update       │
   │                                     │
   ╰─────────────────────────────────────╯			
			]]>
			</screen>
			<para>合约被安装在 node_modules/zeppelin-solidity/contracts 目录</para>
			<para>创建合约和测试文件</para>
			<screen>
			<![CDATA[
neo@MacBook-Pro ~/ethereum/truffle/TokenERC827 % truffle create contract TokenERC827
neo@MacBook-Pro ~/ethereum/truffle/TokenERC827 % truffle create test TokenERC827
			]]>
			</screen>
			<para>编辑合约文件</para>
			<programlisting>
			<![CDATA[
pragma solidity ^0.4.19;
  
import "zeppelin-solidity/contracts/token/ERC827/ERC827Token.sol";

contract TokenERC827 is ERC827Token {

  string public name = "NetkillerCoin";
  string public symbol = "NKC";
  uint8 public decimals = 4;
  uint256 public INITIAL_SUPPLY = 1000000;

  function TokenERC827() public {
    // constructor
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
  }
}
			]]>
			</programlisting>
		</section>
	</section>
</chapter>