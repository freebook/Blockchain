<?xml version="1.0" encoding="UTF-8"?>
<section id="art">
	<title>艺术品区块链溯源防伪平台</title>
	<section>
		<title>都有哪些角色参与其中</title>
		<para>参与艺术品上链，鉴定，交易包含了下面几种角色。</para>
		<itemizedlist>
			<title>平台至少有三种角色会</title>
			<listitem>用户</listitem>
			<listitem>机构</listitem>
			<listitem>鉴定师</listitem>
		</itemizedlist>
		<para>所以我们需要为不同的角色提供不同的App应用。</para>
		<para>用户端：功能包括防伪查询，链上资产的浏览，权益转让，资产拍卖，资产抵押，社区互动，分享，数字资产行情，钱包等等</para>
		<para>机构端：负责信息收集，信息整理，数据提交，数据审查，资产上链，资产划拨等等</para>
		<para>鉴定师：负责数字资产的鉴定，需要有相关资质。</para>

	</section>
	<section>
		<title>需要运用哪些技术</title>
		<itemizedlist>
			<title>防伪溯源涉及的技术栈</title>
			<listitem>纸纹防伪（PaperPrint），纸纹防伪即纸纹防伪技术。它是一种基于提取和识别每张纸与生俱来的、独一无二且无法仿造、克隆的自然纤维纹理作为防伪特征（即纸纹）来实现防伪的新型防伪技术。</listitem>
			<!-- https://www.sinosun.com.cn/paperprint/ -->
			<listitem>荧光防伪油墨，使用荧光油墨印刷技术，在特定波长的紫外线或者红外线下才能看到。荧光二维码，荧光印章，荧光指纹，荧光暗记，布满整个宣纸的荧光图案。我们可以为每个艺术家定制带有荧光图案的专属纸张。</listitem>
			<listitem>DNA防伪, 将艺术家的血液滴在书画上或者头发夹在宣纸中间。据说某中世纪著名画家将自己的精液和油画颜料混合 ：）</listitem>
			<listitem>特征识别防伪，类似我们手机的面部识别，记录物品的特征，例如使用电子显微镜平射纸文理，画面局部等等。油画还可以拍摄X光片。</listitem>
			<listitem>3D 建模扫描，例如3D扫描仪，将物品的3D数据记录下来。</listitem>
			<listitem>激光内雕，例如施华洛世奇将 logo 内雕在他的水晶制品中。</listitem>
			<listitem>QRcode 二维码，用于链上数据查询</listitem>
			<listitem>NFC(Near Field Communication) 有两个作用，一可以存储数据，二用来防伪，因为生产相同UID的NFC芯片难度极大，门槛很高。</listitem>
			<listitem>RFID(Radio Frequency Identification) 是 NFC 的一种，区别是不能存储数据，NFC 不能替代 RFID，RFID 可以实现资产盘点，以及安防。</listitem>
			<listitem>GPS 定位与地图，记录用户位置，资产位置，机构位置，鉴定师位置，还能实现次产跟踪，例如两次查询资产的GPS坐标，不在安全范围，将视为被盗，系统将通知机构或用户。</listitem>
			<listitem>高清相机、高清视频设备</listitem>
			<listitem>安防设备，CCTV监控，门禁等等</listitem>
		</itemizedlist>
	</section>

	<section>
		<title>技术架构</title>
		<!-- <para>区块链项目与传统有很大不同，由于数据存储再公链或者盟链上，服务器，带宽，需要要的技术。</para> -->
		<section>
			<title>前端技术</title>
			<para>由于 H5 技术无法满足我们的需求，例如相机，麦克风，NFC，定位...等等。我们重点放在 App 开发，H5 紧紧用于官网，区块链浏览器，资讯，等等。</para>
			<para>由于使用了很多手机上技术，原生App更适合，而混合开发 React Native，Vue.js, Flutter 不在我们选择之列。</para>
			<para>微信小程序可以考虑，但是如果涉及 Token 可能随时会被下架。</para>
		</section>
		<section>
			<title>微服务端</title>
			<para>服务端设计为可以水平扩展，可以随时根据用户量，扩展服务器规模。</para>
			<para>Nginx 负载均衡，HTTP2 （安卓 Okhttp 已经很好的支持 http2）</para>
			<para>框架采用 Spring cloud</para>
			<para>数据库开发使用 JPA</para>
			<para>接口认证 Oauth2 + Jwt</para>
			<para></para>
		</section>
		<section>
			<title>存储层</title>
			<para>MongoDB</para>
			<para>Redis</para>
		</section>
		<section>
			<title>消息队列层</title>
			<para>Kafka</para>
		</section>
		<section>
			<title>搜索层</title>
			<para>ELK(ElasticSearch, Logstash, Kibana)</para>
			<para>搜索是非常重要的功能，因为区块链只能通过 hash 值取出链上的数据，虽然 Hyperledger Fabrc 在数据使用 CouchDB 时提供了 World State 的一些高级搜索功能，但是仍然不能满足我们的需求。</para>
			<para>所以链上数据需要存储一份在搜索引擎中，搜索引擎的分词功能，可以提供快速精准的搜索服务。</para>
			<para>搜索引擎的工作流程是：</para>
			<screen>
			<![CDATA[
User --> Phone App --> Nginx --> Spring cloud --> Elastsearch --> Hyperledger Fabric	
			]]>
			</screen>
		</section>
		<section>
			<title>区块链</title>
			<para>我们不做山寨链，我发现很多国内企业热衷于做山寨链，什么事山寨链呢，就是在现有的区块链(Ethereum, Hyperledger Fabric 或 EOS) 的基础上二次开发，首先开发山寨链需要大量的资金人力，私链是没有任何意义的，没有公信力。即使目前的现有区块链无法满足我们的需求，可以通过架构调节去适应他。</para>
			<para>所以我们只用最成熟的产品：</para>
			<para>Hyperledger Fabric 盟链：主要用于资产上链，链上资产查询</para>
			<para>Ethereum 公链：用于 Token ，由于 Hyperledger Fabric 无法实现 Token，所以我们仍然需要以太坊。（作者写过一篇文章关于为什么Hyperledger Fabric 不能实现 Token，请兴趣自己在网上搜索） </para>
			<para>EOS Token/资产上链：由于在我设计这个系统之时 EOS 还没有 Release 所以当时没有考虑 EOS。现在我们可以使用 EOS，甚至替换掉 Hyperledger Fabrc + Ethereum 方案。因为 EOS 即能实现资产上链，也能实现 Token。 这里我们将资产也在 EOS 上链一份，同时也支持 EOS 发的 Token。</para>
			<para>IPFS 星际文件系统：用于存储多媒体数据，例如图片，视频。（注意：IPFS 暂时不支持流媒体，我的解决方案是上链同事复制一份到 nginx 中，并开启 mp4 流媒体功能）</para>
			<para>注：虽然以太坊目前尝尝拥堵，但是很多应用场景仍是不可替代的。</para>
		</section>
		<section>
			<title>支持层</title>
			<para>监控 Zabbix</para>
		</section>
	</section>

	<section id="nfc">
		<title>RFID/NFC</title>
		<para>NFC基本概念：  </para>
		<para>NFC(Near Field Communication)缩写，即近距离无线通讯技术。由飞利浦公司和索尼公司共同开发的一项无线技术。NFC由非接触式射频识别及互联互通技术整合演变而来，可以在移动设备、消费类电子产品、PC和智能控件工具间进行近距离无线通信。NFC提供了一种简单、触控式的解决方案，可以让消费者简单直观地交换信息、访问内容与服务。  NFC技术特点：  1、 在13.56MHz频率运行距离在20公分内；  2、 传输速度可分106Kbits/sec，212 Kbits/sec，424 Kbits/sec；  3、 运作可分主动与被动模式。主动模式需使用电池，也需要独立发射模组；被动模式不需使用电池，但无法独立发射讯号；  4、 已成为ISO/IEC IS 18092国家标准、ETSI TS 102 190标准、EMCA-340标准。</para>

		<para>RFID基本概念：</para>
		<para>RFID(Radio Frequency Identification)的缩写，即射频识别，俗称电子标签。  RFID射频识别是一种非接触式的自动识别技术，它通过射频信号自动识别目标对象并获取相关数据，识别工作无须人工干预，可工作于各种恶劣环境。  RFID是一种简单的无线系统，只有两个基本器件，该系统用于控制、检测和跟踪物体。系统由一个询问器(或阅读器)和很多应答器(或标签)组成。 </para>
		<para>RFID包括：  低频125KHz  主要是动物管理  中频 一般指433MHz（这个频段一般也是有源的 也有做高速收费）  高频13.56MHz 公交卡 身份证都是这个频段。  超高频860-960MHz 主要用在物流和停车场管理。 微波2.45GHz  ETC用这个频段的多</para>

		<itemizedlist>
			<title>RFID/NFC 比较</title>
			<listitem>距离，RFID远，NFC进</listitem>
			<listitem>RIFD由读卡器和标签组成，读卡器只能读取标签上的数据。NFC既可以做读卡器，也能提供标签服务，还能实现P2P点对点传输数据。</listitem>
			<listitem>修改，RFID是只读的，NFC上的数据可以修改，例如公交卡</listitem>
			<listitem></listitem>
		</itemizedlist>
		<para>NFC 标签可以使用易碎纸粘贴在艺术品上，缺点是寿命较短。使用PVC材料又容易撕下。</para>
		<section>
			<title>手机NFC功能</title>
			<para>NFC是近场通信，支持13.56MHz，因此用手机的NFC来读取13.56MHz的RFID电子标签，在硬件上是没有问题的.</para>
		</section>
		<section>
			<title>NFC 标准</title>
			<para>历史记录</para>
			<screen>
			<![CDATA[
ISO14443-4
ISO14443-3A
ISO14443-3B	
			]]>
			</screen>
			<para>NTAG21x系列容量大小</para>

			<screen>
			<![CDATA[
NTAG210 48byte
NTAG213 144byte
NTAG215 504byte
NTAG216，888byte	
			]]>
			</screen>

		</section>
		<section id="nfc.date">
			<title>NFC 数据格式</title>
			<section id="NDEF">
				<title>NDEF (NFC Data Exchange Format)</title>
				<screen>
			<![CDATA[
Value    Protocol
-----    --------
0x00     No prepending is done ... the entire URI is contained in the URI Field
0x01     http://www.
0x02     https://www.
0x03     http://
0x04     https://
0x05     tel:
0x06     mailto:
0x07     ftp://anonymous:anonymous@
0x08     ftp://ftp.
0x09     ftps://
0x0A     sftp://
0x0B     smb://
0x0C     nfs://
0x0D     ftp://
0x0E     dav://
0x0F     news:
0x10     telnet://
0x11     imap:
0x12     rtsp://
0x13     urn:
0x14     pop:
0x15     sip:
0x16     sips:
0x17     tftp:
0x18     btspp://
0x19     btl2cap://
0x1A     btgoep://
0x1B     tcpobex://
0x1C     irdaobex://
0x1D     file://
0x1E     urn:epc:id:
0x1F     urn:epc:tag:
0x20     urn:epc:pat:
0x21     urn:epc:raw:
0x22     urn:epc:
0x23     urn:nfc:		
			]]>
				</screen>
			</section>

		</section>
		<section id="MifareUltralight">
			<title>MifareUltralight</title>
			<para>艺术品数字身份证</para>
			<para>ID</para>
			<screen>
			<![CDATA[
将NFC标签的存储区域分为16个页，每一个页可以存储4个字节，一个可存储64个字节（512位）。页码从0开始（0至15）。前4页（0至3）存储了NFC标签相关的信息（如NFC标签的序列号、控制位等）。从第5页开始存储实际的数据（4至15页）。
			]]>
			</screen>

		</section>
		<section>
			<title>MifareClassic</title>
		</section>
		<section>
			<title>NXP（恩智浦）相关产品</title>

			<section>
				<title>Mifare</title>

			</section>
		</section>
	</section>
	<section>
		<title>资产投资与份额持有</title>
		<para>传统艺术品投资门槛非常高，一是用户不知道从哪些渠道可以投资，二是艺术品价值过高，三是艺术品简单难。这导致了投资艺术品门槛过高。 Token 能实现份额化，实现人人参与，人人持有，P2P交易。</para>
		<para>例如某机构上链一件艺术品，用户可以投资该艺术品的一定份额，可以转让他持有的权益。且交易去中心化，不受任何机构，管理者的制约。</para>
		<para>下面的合约可以展示如何分割艺术品份额，最终达到链上资产的份额分割和持有与交易。</para>
		<screen>
		<![CDATA[
pragma solidity ^0.4.25;

/**
 * @title SafeMath
 * @dev Math operations with safety checks that revert on error
 */
library SafeMath {

  /**
  * @dev Multiplies two numbers, reverts on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    uint256 c = a * b;
    require(c / a == b);

    return c;
  }

  /**
  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b > 0); // Solidity only automatically asserts when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return c;
  }

  /**
  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a);
    uint256 c = a - b;

    return c;
  }

  /**
  * @dev Adds two numbers, reverts on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a);

    return c;
  }

  /**
  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
  * reverts when dividing by zero.
  */
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b != 0);
    return a % b;
  }
}        

contract Ownable {
    
    address public owner;
    
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    
    constructor() public {
        owner = msg.sender;
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    
    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }

}

contract NetkillerAssetsToken is Ownable {
    using SafeMath for uint256;
    
    string public name;
    string public symbol;
    uint public decimals;
    uint256 public totalSupply;
    
    mapping(address => mapping(string => uint256)) internal balances;
    mapping(string => address) internal tokens;
    
    event Transfer(address indexed _from, address indexed _to, string indexed _tokenId);
    event Burn(address indexed from, string _tokenId);
    
    constructor(
        string tokenName,
        string tokenSymbol,
        uint decimalUnits
    ) public {
        owner = msg.sender;
        name = tokenName;
        symbol = tokenSymbol; 
        decimals = decimalUnits;
        totalSupply = 0; 
    }
    
    function add(address _owner, string _tokenId) onlyOwner returns(bool status){
        balances[_owner][_tokenId] = 100 * 10 ** uint256(decimals);
        tokens[_tokenId] = _owner;
        totalSupply = totalSupply.add(1);
        return true;
    }
    
    function balanceOf(address _owner, string _tokenId) constant returns(uint balance){ 
        return balances[_owner][_tokenId];
    }

    function ownerOf(string _tokenId) constant returns (address owner) {
        return tokens[_tokenId];
    }
    
    function transfer(address _to, string _tokenId){
        
        address _from = msg.sender;
        uint256 amount = balances[_from][_tokenId];
        transfer(_to, amount, _tokenId);
    }
    function transfer(address _to, uint256 _value, string _tokenId){
        require(msg.sender == ownerOf(_tokenId));
        require(msg.sender != _to);
        require(_to != address(0));
        
        address _from = msg.sender;
        uint256 amount = balances[_from][_tokenId];
        require(amount >= _value);
        
        balances[_from][_tokenId] = balances[_from][_tokenId].sub(_value);
        balances[_to][_tokenId] = balances[_to][_tokenId].add(_value);
        tokens[_tokenId] = _to;

        emit Transfer(_from, _to, _tokenId);
    }
    
    function burn(address _owner, string _tokenId) onlyOwner public returns (bool success) {
        require(balances[_owner][_tokenId] > 0 && balances[_owner][_tokenId] == 100 * 10 ** uint256(decimals));

        balances[_owner][_tokenId] = 0;
        tokens[_tokenId] = address(0);

        totalSupply = totalSupply.sub(1);
        emit Burn(msg.sender, _tokenId);
        return true;
    }
    
}		
		]]>
		</screen>
		<para>由于 ERC721 不太符合我的需求，所以我结合 ERC20 和 ERC721 写出了我的合约。合约尽量保持了ERC20的使用习惯，函数定义尽量兼容 ERC20。</para>
		<para>我们来看下面的构造方法，每个种类的物品一个合约，例如字画，陶瓷，青铜器。</para>
		<screen>
		<![CDATA[
    constructor(
        string tokenName,
        string tokenSymbol,
        uint decimalUnits
    ) public {
        owner = msg.sender;
        name = tokenName;
        symbol = tokenSymbol; 
        decimals = decimalUnits;
        totalSupply = 0; 
    }
		]]>
		</screen>
		<para>通过下面函数，添加资产到 Token，使链上资产与Token绑定。</para>
		<screen>
		<![CDATA[
    function add(address _owner, string _tokenId) onlyOwner returns(bool status){
        balances[_owner][_tokenId] = 100 * 10 ** uint256(decimals);
        tokens[_tokenId] = _owner;
        totalSupply = totalSupply.add(1);
        return true;
    }		
		]]>
		</screen>
		<para>balances[_owner][_tokenId] = 100 * 10 ** uint256(decimals); 初始化份额是 100 表示 100%</para>
		<para>totalSupply = totalSupply.add(1); 物品件数加一。可以用于统计链上资产的数量。</para>
		<para>下面函数是查询资产的持有人</para>
		<screen>
		<![CDATA[
function ownerOf(string _tokenId) constant returns (address owner) {
        return tokens[_tokenId];
    }		
		]]>
		</screen>
		<para>下面函数是，权益转让和权益份额转让。</para>
		<screen>
		<![CDATA[
    function transfer(address _to, string _tokenId){
        
        address _from = msg.sender;
        uint256 amount = balances[_from][_tokenId];
        transfer(_to, amount, _tokenId);
    }
    function transfer(address _to, uint256 _value, string _tokenId){
        require(msg.sender == ownerOf(_tokenId));
        require(msg.sender != _to);
        require(_to != address(0));
        
        address _from = msg.sender;
        uint256 amount = balances[_from][_tokenId];
        require(amount >= _value);
        
        balances[_from][_tokenId] = balances[_from][_tokenId].sub(_value);
        balances[_to][_tokenId] = balances[_to][_tokenId].add(_value);
        tokens[_tokenId] = _to;

        emit Transfer(_from, _to, _tokenId);
    }		
		]]>
		</screen>
		<para>接下来，我们就是可以开发 Dapp 钱包了，在钱包中实现资产的转移交易。</para>
		<para>这个合约可以一直到 EOS 上，Hyperledger Fabric 不可以，因为 Fabric 没有锁的机制，会导致计算出错。</para>
	</section>
	<section>
		<title>原型设计</title>
	</section>
</section>